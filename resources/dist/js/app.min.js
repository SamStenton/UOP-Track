/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// Page Dispatcher
	// Runs on every page and loads 
	// a matching Javascript Page if it exists
	var PageDispatcher = new (__webpack_require__(1))();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var CreateModulePage = __webpack_require__(2);
	
	class PageDispatcher {
	    constructor() {
	        this.pages = this.registerPages();
	        this.loadPage();
	    }
	
	    /**
	     * Pages to be checked should be placed here
	     *
	     * @return     {Object}  Pages Classes
	     */
	    registerPages() {
	        return {
	            CreateModulePage: new CreateModulePage()
	        };
	    }
	
	    /**
	     * Loops through the registered pages 
	     * checking if each can fulfill the
	     * current page. If so the execute
	     * method is run on the returned
	     * Page
	     */
	    loadPage() {
	        for (let page in this.pages) {
	            if (this.pages[page].canFulfill()) {
	                this.pages[page].execute();
	                break;
	            }
	        }
	    }
	}
	
	module.exports = PageDispatcher;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var Page = __webpack_require__(3);
	var Form = __webpack_require__(4);
	var ModuleItemGen = __webpack_require__(7);
	
	class createModule extends Page {
	    constructor() {
	        super();
	        this.selector = "create-module";
	        this.submissions = [];
	        this.form = new Form({
	            name: '',
	            submissions: []
	        });
	        this.moduleItemFactory = new ModuleItemGen(this.getByDataAttr('item="items"'));
	    }
	
	    /**
	     * Checks for a unique element on a page to 
	     *
	     * @return     {boolean}  True if able to fulfill, False otherwise.
	     */
	    canFulfill() {
	        return document.querySelectorAll(`[data-page="${this.selector}"]`).length > 0;
	    }
	
	    /**
	     * Entry Method for the current page. Envoked via PageDispatcher.js
	     * 
	     */
	    execute() {
	        this.getByName('module_name').addEventListener('keyup', event => {
	            this.form.name = event.target.value;
	            this.updateDisplay('module_name', event);
	        });
	        this.getByID('addSubmission').addEventListener('click', event => this.addSubmission(event));
	        this.getByID('submitForm').addEventListener('click', event => this.submitForm(event));
	    }
	
	    /**
	     * Submits form to the server
	     *
	     * @param      {event}  event   Submit event
	     */
	    submitForm(event) {
	        event.preventDefault();
	        this.form.submissions = this.submissions;
	        this.form.post('/api/module/create');
	    }
	
	    /**
	     * Adds a submission to the form object 
	     *
	     * @param      {Event}  event   add event
	     */
	    addSubmission(event) {
	        event.preventDefault();
	        let item = {
	            name: this.getByName('submission_name').value,
	            weight: this.getByName('submission_weight').value,
	            grade: this.getByName('submission_grade').value
	        };
	
	        this.moduleItemFactory.addItem(item);
	        this.moduleItemFactory.generate();
	        this.moduleItemFactory.inject();
	
	        this.submissions.push(item);
	        this.clearInputs(['submission_name', 'submission_weight', 'submission_grade']);
	    }
	
	    /**
	     * Ouputs the users input in the the corrisponding Module Display
	     *
	     * @param      {String}  selector  Parent HTML selector
	     * @param      {Event}  event     The event
	     */
	    updateDisplay(selector, event) {
	        this.getByDataAttr(`item="${selector}"`).innerHTML = event.target.value;
	    }
	}
	
	module.exports = createModule;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var Form = __webpack_require__(4);
	var form = new Form();
	
	class Page {
	    constructor() {
	        this.selector = undefined;
	    }
	
	    /**
	     * This is basically and abstract class so shouldn't
	     * have the ability to fulfill any requests
	     *
	     * @return     {boolean}  True if able to fulfill, False otherwise.
	     */
	    canFulfill() {
	        return false;
	    }
	
	    /**
	     * Entry into page. Should be overridden
	     */
	    execute() {
	        console.log('execute() method does not exist. Please create it');
	    }
	
	    /**
	     * Gets an element by its ID
	     *
	     * @param      {string}  id      ID of element
	     * @return     {HTMLElement}  Selected element 
	     */
	    getByID(id) {
	        return document.querySelectorAll(`[id="${id}"]`)[0];
	    }
	
	    /**
	     * Gets an element by its name
	     * This would usually be 
	     * an input
	     *
	     * @param      {string}  name    Input Name
	     * @return     {HtmlElement}  Selected element
	     */
	    getByName(name) {
	        return document.querySelectorAll(`[name="${name}"]`)[0];
	    }
	
	    /**
	     * Selects an element by its class name
	     *
	     * @param      {String}  name    Class name 
	     * @return     {HMTLElement}  Selected element
	     */
	    getByClass(name) {
	        return document.querySelectorAll(`[class="${name}"]`)[0];
	    }
	
	    /**
	     * Selects element by its Data attribute
	     *
	     * @param      {String}  name    Data attribute
	     * @return     {HTMLElement}  Selected element
	     */
	    getByDataAttr(name) {
	        return document.querySelectorAll(`[data-${name}`)[0];
	    }
	
	    /**
	     * Clears an inputs value
	     *
	     * @param      {String}  name    Inputs name
	     */
	    clearInput(name) {
	        this.getByName(name).value = "";
	    }
	
	    /**
	     * Clears multiple input values
	     *
	     * @param      {Array}  inputs  The inputs
	     */
	    clearInputs(inputs) {
	        for (let input in inputs) {
	            this.clearInput(inputs[input]);
	        }
	    }
	}
	
	module.exports = Page;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var axios = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"axios\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var FormErrors = __webpack_require__(6);
	class Form {
	    /**
	     * Create a new Form instance.
	     *
	     * @param {object} data
	     */
	    constructor(data) {
	        this.originalData = data;
	        this.errors = new FormErrors();
	    }
	
	    setOriginalData(data) {
	        this.originalData = data;
	
	        for (let field in data) {
	            this[field] = data[field];
	        }
	    }
	
	    addData(key, value) {
	        this.originalData[key] = value;
	
	        for (let field in this.originalData) {
	            this[field] = this.originalData[field];
	        }
	    }
	
	    /**
	     * Fetch all relevant data for the form.
	     */
	    data() {
	        let data = {};
	
	        for (let property in this.originalData) {
	            data[property] = this[property];
	        }
	
	        return data;
	    }
	
	    /**
	     * Reset the form fields.
	     */
	    reset() {
	        for (let field in this.originalData) {
	            this[field] = '';
	        }
	
	        this.errors.clear();
	    }
	
	    /**
	     * Send a POST request to the given URL.
	     * .
	     * @param {string} url
	     */
	    post(url) {
	        return this.submit('post', url);
	    }
	
	    /**
	     * Submit the form.
	     *
	     * @param {string} requestType
	     * @param {string} url
	     */
	    submit(requestType, url) {
	        return new Promise((resolve, reject) => {
	            axios[requestType](url, this.data()).then(response => {
	                this.onSuccess(response.data);
	
	                resolve(response.data);
	            }).catch(error => {
	                this.onFail(error.response.data);
	
	                reject(error.response.data);
	            });
	        });
	    }
	
	    /**
	     * Handle a successful form submission.
	     *
	     * @param {object} data
	     */
	    onSuccess(data) {
	        alert(data.message); // temporary
	
	        this.reset();
	    }
	
	    /**
	     * Handle a failed form submission.
	     *
	     * @param {object} errors
	     */
	    onFail(errors) {
	        this.errors.record(errors);
	    }
	}
	
	module.exports = Form;

/***/ },
/* 5 */,
/* 6 */
/***/ function(module, exports) {

	class FormErrors {
	    /**
	     * Create a new Errors instance.
	     */
	    constructor() {
	        this.errors = {};
	    }
	
	    /**
	     * Determine if an errors exists for the given field.
	     *
	     * @param {string} field
	     */
	    has(field) {
	        return this.errors.hasOwnProperty(field);
	    }
	
	    /**
	     * Determine if we have any errors.
	     */
	    any() {
	        return Object.keys(this.errors).length > 0;
	    }
	
	    /**
	     * Retrieve the error message for a field.
	     *
	     * @param {string} field
	     */
	    get(field) {
	        if (this.errors[field]) {
	            return this.errors[field][0];
	        }
	    }
	
	    /**
	     * Record the new errors.
	     *
	     * @param {object} errors
	     */
	    record(errors) {
	        this.errors = errors;
	    }
	
	    /**
	     * Clear one or all error fields.
	     *
	     * @param {string|null} field
	     */
	    clear(field) {
	        if (field) {
	            delete this.errors[field];
	
	            return;
	        }
	
	        this.errors = {};
	    }
	}
	
	module.exports = FormErrors;

/***/ },
/* 7 */
/***/ function(module, exports) {

	class ModuleItem {
	    constructor(itemContainer) {
	        this.container = itemContainer;
	        this.items = new Array();
	        this.generated = "";
	        this.container.innerHTML = "";
	    }
	
	    /**
	     * Adds an item to the list of items
	     *
	     * @param      {Object}  item    The item
	     */
	    addItem(item) {
	        this.items.push(item);
	    }
	
	    /**
	     * Generates an Module Submission html elements
	     * using the template given from items passed
	     * to the addItem method
	     */
	    generate() {
	        this.generated = "";
	        for (let item in this.items) {
	            item = this.items[item];
	            let grade = item.grade != "" ? `${item.grade}%` : 'Pending';
	            let string = `
	                <div class="item">
	                  <div class="type">?</div>
	                  <div class="details">
	                    <h4>${item.name}</h4>
	                    <div class="weighting">Weighting: ${item.weight}%</div>
	                  </div>
	                  <div class="grade pending">${grade}</div>
	                </div>`;
	
	            this.generated += string.trim();
	        }
	    }
	
	    /**
	     * Inject the generated html into the given
	     * HTML parent
	     */
	    inject() {
	        this.container.innerHTML = this.generated;
	    }
	}
	
	module.exports = ModuleItem;

/***/ }
/******/ ]);
//# sourceMappingURL=app.min.js.map